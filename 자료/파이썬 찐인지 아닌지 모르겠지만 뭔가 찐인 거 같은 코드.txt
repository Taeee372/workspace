"""ì–‘ê³„ì¥ í™˜ê²½ ì„¼ì„œ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ (ìµœì í™” ë²„ì „)"""
import logging
import math
import time
import threading
from contextlib import contextmanager
from datetime import datetime, timedelta
from typing import Optional, Tuple, Dict, Any
from decimal import Decimal

# í•˜ë“œì›¨ì–´ ê´€ë ¨ (í•„ìš”ì‹œì—ë§Œ import)
try:
    import board
    import adafruit_dht
    import spidev
    import RPi.GPIO as GPIO
    import mysql.connector
    import requests
    from flask import Flask, jsonify, request
    from flask_cors import CORS
    HARDWARE_AVAILABLE = True
except ImportError as e:
    logging.warning(f"í•˜ë“œì›¨ì–´ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì¼ë¶€ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: {e}")
    HARDWARE_AVAILABLE = False


# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('env_monitor.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Flask ë¡œê±° ì„¤ì • (ì½˜ì†”ì—ì„œë§Œ ìˆ¨ê¸°ê¸°)
werkzeug_logger = logging.getLogger('werkzeug')
werkzeug_logger.setLevel(logging.WARNING)  # INFO ë ˆë²¨ ë¡œê·¸ ìˆ¨ê¹€

# ë¡œê·¸ íŒŒì¼ ìƒì„± í™•ì¸
logger.info("ë¡œê·¸ íŒŒì¼ ì •ìƒ ìƒì„± í™•ì¸ë¨")

# ========== Flask ì„œë²„ ì¶”ê°€ ==========
app = Flask(__name__)
CORS(app)

# ì „ì—­ ë³€ìˆ˜ë¡œ ìµœì‹  ì„¼ì„œ ë°ì´í„° ì €ì¥
latest_sensor_data = {
    'temperature': 0,
    'humidity': 0,
    'lux': 0,
    'co2': 0,
    'no2': 0,
    'co': 0,
    'nh3': 0,
    'timestamp': None,
    'is_warming': False  # ì‹œì‘ ì‹œ ì •ìƒ ìƒíƒœë¡œ ì„¤ì •
}

# ìµœê·¼ 30ì´ˆê°„ì˜ ì„¼ì„œ ë°ì´í„° íˆìŠ¤í† ë¦¬ ì €ì¥ (2ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸)
sensor_history = {
    'temperature': [],
    'humidity': [],
    'lux': [],
    'co2': [],
    'no2': [],
    'co': [],
    'nh3': [],
    'timestamps': []
}
MAX_HISTORY_SIZE = 15  # 30ì´ˆ Ã· 2ì´ˆ = 15ê°œ ë°ì´í„° í¬ì¸íŠ¸

# ì „ì—­ ë³€ìˆ˜ë¡œ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ ì €ì¥
system_instance = None

def update_sensor_history(sensor_data):
    """ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ (ìµœê·¼ 30ì´ˆê°„ ë°ì´í„° ìœ ì§€)"""
    global sensor_history
    
    current_time = datetime.now().isoformat()
    
    # ê° ì„¼ì„œ ë°ì´í„° ì¶”ê°€
    for sensor_type in ['temperature', 'humidity', 'lux', 'co2', 'no2', 'co', 'nh3']:
        if sensor_type in sensor_data:
            sensor_history[sensor_type].append(sensor_data[sensor_type])
            
            # ìµœëŒ€ í¬ê¸° ì´ˆê³¼ ì‹œ ì˜¤ë˜ëœ ë°ì´í„° ì œê±°
            if len(sensor_history[sensor_type]) > MAX_HISTORY_SIZE:
                sensor_history[sensor_type].pop(0)
    
    # íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
    sensor_history['timestamps'].append(current_time)
    if len(sensor_history['timestamps']) > MAX_HISTORY_SIZE:
        sensor_history['timestamps'].pop(0)

# Flask API ì—”ë“œí¬ì¸íŠ¸
@app.route('/api/realtime')
def get_realtime():
    """ì‹¤ì‹œê°„ ì„¼ì„œ ë°ì´í„°"""
    # ì˜ˆì—´ ì¤‘ì¼ ë•ŒëŠ” ë°ì´í„° ì œê³µí•˜ì§€ ì•ŠìŒ
    is_warming = latest_sensor_data.get('is_warming', False)
    
    if is_warming:
        logger.debug(f"ğŸš« ì˜ˆì—´ ì¤‘ - API ìš”ì²­ ì°¨ë‹¨: is_warming={is_warming}")
        return jsonify({
            'success': False,
            'message': 'ì„¼ì„œ ì˜ˆì—´ ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.',
            'is_warming': True
        })
    
    logger.debug(f"âœ… ì •ìƒ ëª¨ë“œ - API ìš”ì²­ í—ˆìš©: is_warming={is_warming}")
    return jsonify({
        'success': True,
        'data': latest_sensor_data
    })

@app.route('/api/status')
def get_status():
    """ì‹œìŠ¤í…œ ìƒíƒœ"""
    return jsonify({
        'success': True,
        'message': 'ë¼ì¦ˆë² ë¦¬íŒŒì´ ì„¼ì„œ ì‹œìŠ¤í…œ ì‘ë™ ì¤‘',
        'is_warming': latest_sensor_data.get('is_warming', False),
        'timestamp': latest_sensor_data.get('timestamp'),
        'controls': device_states,  # í˜„ì¬ ê¸°ê¸° ìƒíƒœ
        'modes': control_modes      # í˜„ì¬ ì œì–´ ëª¨ë“œ
    })

# 3. ì„¤ì • ì ìš© API ìˆ˜ì •
@app.route('/api/settings/apply', methods=['POST'])
def apply_settings():
    """ì„¤ì • ì ìš© ìš”ì²­ ì²˜ë¦¬"""
    try:
        global system_instance
        if system_instance and hasattr(system_instance, 'settings_manager'):
            # ì„¤ì •ì„ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë‹¤ì‹œ ë¡œë“œí•˜ì—¬ ìµœì‹  ìƒíƒœë¡œ ë™ê¸°í™”
            success = system_instance.settings_manager.load_settings_from_db()
            if success:
                logger.info("ì„¤ì •ì´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¡œë“œë˜ì–´ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.")
                return jsonify({
                    'success': True,
                    'message': 'ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.'
                })
            else:
                return jsonify({
                    'success': False,
                    'message': 'ì„¤ì • ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'
                })
        else:
            return jsonify({
                'success': False,
                'message': 'ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            })
    except Exception as e:
        logger.error(f"ì„¤ì • ì ìš© ì‹¤íŒ¨: {e}")
        return jsonify({
            'success': False,
            'message': f'ì„¤ì • ì ìš© ì‹¤íŒ¨: {str(e)}'
        }), 500


# 1. ì„¤ì • ì—…ë°ì´íŠ¸ API ìˆ˜ì •
@app.route('/api/settings/update', methods=['POST'])
def update_settings():
    """ì„¤ì •ì„ ì§ì ‘ ì—…ë°ì´íŠ¸í•˜ê³  ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥"""
    try:
        settings_data = request.get_json()
        if not settings_data:
            return jsonify({
                'success': False,
                'message': 'ì„¤ì • ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.'
            }), 400
        
        # ì „ì—­ ë³€ìˆ˜ë¡œ ì„¤ì • ê´€ë¦¬ìì— ì ‘ê·¼
        global system_instance
        if system_instance and hasattr(system_instance, 'settings_manager'):
            # 1. ë©”ëª¨ë¦¬ì— ì„¤ì • ì—…ë°ì´íŠ¸
            for key, value in settings_data.items():
                if hasattr(system_instance.settings_manager, 'settings'):
                    system_instance.settings_manager.settings[key] = value
            
            # 2. ğŸ”¥ í•µì‹¬: ë°ì´í„°ë² ì´ìŠ¤ì— ì„¤ì • ì €ì¥
            success = save_settings_to_db(settings_data)
            
            if success:
                logger.info(f"ì„¤ì •ì´ ë©”ëª¨ë¦¬ì™€ DBì— ëª¨ë‘ ì—…ë°ì´íŠ¸ë¨: {settings_data}")
                return jsonify({
                    'success': True,
                    'message': 'ì„¤ì •ì´ ì„±ê³µì ìœ¼ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    'data': settings_data
                })
            else:
                return jsonify({
                    'success': False,
                    'message': 'ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.'
                }), 500
        else:
            return jsonify({
                'success': False,
                'message': 'ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.'
            }), 500
    except Exception as e:
        logger.error(f"ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
        return jsonify({
            'success': False,
            'message': f'ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}'
        }), 500
        
# 2. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ í•¨ìˆ˜ ì¶”ê°€
def save_settings_to_db(settings_data):
    """ì„¤ì •ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥"""
    try:
        global system_instance
        if not system_instance or not hasattr(system_instance, 'db_manager'):
            return False
        
        with system_instance.db_manager.get_connection() as conn:
            if not conn:
                return False
            
            cursor = conn.cursor()
            
            # ì„¤ì •ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥
            for key, value in settings_data.items():
                # ì„¤ì • í‚¤ë¥¼ DB ì»¬ëŸ¼ëª…ìœ¼ë¡œ ë§¤í•‘
                column_mapping = {
                    'ledThreshold': 'LED_THRESHOLD',
                    'doorOpenTemp': 'DOOR_OPEN_TEMP',
                    'doorCloseTemp': 'DOOR_CLOSE_TEMP',
                    'fanHumidityThreshold': 'FAN_HUMIDITY_THRESHOLD',
                    'fanCO2Threshold': 'FAN_CO2_THRESHOLD',
                    'fanCOThreshold': 'FAN_CO_THRESHOLD',
                    'fanSpeed': 'FAN_SPEED',
                    'tempHighAlert': 'TEMP_HIGH_ALERT',
                    'tempLowAlert': 'TEMP_LOW_ALERT',
                    'humidityHighAlert': 'HUMIDITY_HIGH_ALERT',
                    'humidityLowAlert': 'HUMIDITY_LOW_ALERT',
                    'co2Alert': 'CO2_ALERT',
                    'coAlert': 'CO_ALERT',
                    'nh3Alert': 'NH3_ALERT',
                    'envStatusGood': 'ENV_STATUS_GOOD',
                    'envStatusFair': 'ENV_STATUS_FAIR',
                    'autoLedMode': 'AUTO_LED_MODE',
                    'manualLedThreshold': 'MANUAL_LED_THRESHOLD',
                    'locationLat': 'LOCATION_LAT',
                    'locationLng': 'LOCATION_LNG',
                    'sleepStartHour': 'SLEEP_START_HOUR',
                    'sleepEndHour': 'SLEEP_END_HOUR',
                    'sleepModeEnabled': 'SLEEP_MODE_ENABLED',
                    'servoThreshold': 'SERVO_THRESHOLD',
                    'useSimpleSensorMode': 'USE_SIMPLE_SENSOR_MODE'
                }
                
                if key in column_mapping:
                    db_column = column_mapping[key]
                    sql = f"UPDATE ENV_SETTINGS SET {db_column} = %s WHERE ID = 1"
                    cursor.execute(sql, (value,))
                    logger.info(f"DB ì—…ë°ì´íŠ¸: {db_column} = {value}")
            
            conn.commit()
            cursor.close()
            return True
            
    except Exception as e:
        logger.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥ ì‹¤íŒ¨: {e}")
        return False

from decimal import Decimal

@app.route('/api/settings/current', methods=['GET'])
def get_current_settings():
    """í˜„ì¬ ì„¤ì • ì¡°íšŒ"""
    try:
        global system_instance
        
        # ê¸°ë³¸ ì„¤ì •ê°’
        default_settings = {
            'ledThreshold': 300,
            'autoLedMode': True,
            'manualLedThreshold': 300,
            'locationLat': 37.5665,
            'locationLng': 126.9780,
            'sleepStartHour': 22,
            'sleepEndHour': 6,
            'sleepModeEnabled': True,
            'doorOpenTemp': 25,
            'doorCloseTemp': 15,
            'fanHumidityThreshold': 75,
            'fanCO2Threshold': 1000,
            'fanCOThreshold': 30,
            'fanSpeed': 60,
            'tempHighAlert': 35,
            'tempLowAlert': 10,
            'humidityHighAlert': 85,
            'humidityLowAlert': 30,
            'co2Alert': 2000, # ì„ê³„
            'coAlert': 50,
            'nh3Alert': 25,
            'envStatusGood': 80,
            'envStatusFair': 60,
            'servoThreshold': 60,
            'useSimpleSensorMode': False
        }
        
        # ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ í™•ì¸
        if system_instance is None:
            logger.warning("âš ï¸ ì‹œìŠ¤í…œ ì¸ìŠ¤í„´ìŠ¤ê°€ ì•„ì§ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ")
            return jsonify({
                'success': True,
                'data': default_settings,
                'message': 'ê¸°ë³¸ ì„¤ì •ê°’ (ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¤‘)'
            })
        
        if not hasattr(system_instance, 'settings_manager'):
            logger.error("âŒ ì„¤ì • ê´€ë¦¬ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ")
            return jsonify({
                'success': True,
                'data': default_settings,
                'message': 'ê¸°ë³¸ ì„¤ì •ê°’ (ì„¤ì • ê´€ë¦¬ì ì—†ìŒ)'
            })
        
        # í˜„ì¬ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        current_settings = system_instance.settings_manager.settings
        
        # ğŸ”¥ í•µì‹¬: Decimalê³¼ datetimeì„ JSON ì§ë ¬í™” ê°€ëŠ¥í•œ íƒ€ì…ìœ¼ë¡œ ë³€í™˜
        settings_dict = {}
        for key, value in current_settings.items():
            if isinstance(value, Decimal):
                settings_dict[key] = float(value)
            elif hasattr(value, 'isoformat'):  # datetime ê°ì²´
                settings_dict[key] = value.isoformat()
            else:
                settings_dict[key] = value
        
        logger.info(f"âœ… í˜„ì¬ ì„¤ì • ì¡°íšŒ ì„±ê³µ")
        
        return jsonify({
            'success': True,
            'data': settings_dict
        })
        
    except Exception as e:
        logger.error(f"âŒ í˜„ì¬ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨: {e}", exc_info=True)
        
        # ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ê¸°ë³¸ê°’ ë°˜í™˜ (500 ì—ëŸ¬ ë°©ì§€)
        return jsonify({
            'success': True,
            'data': default_settings,
            'message': f'ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: {str(e)}'
        })

@app.route('/api/settings/simple', methods=['GET'])
def get_simple_settings():
    """í˜„ì¬ ì„¤ì • ì¡°íšŒ (ì•±)"""
    try:
        global system_instance
        
        # ê¸°ë³¸ê°’
        result_settings = {
            'doorOpenTemp': 28,
            'doorCloseTemp': 24,
            'fanHumidityThreshold': 70,
            'fanCO2Threshold': 1000
        }
        
        # ì‹œìŠ¤í…œì—ì„œ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
        if system_instance and hasattr(system_instance, 'settings_manager'):
            try:
                settings = system_instance.settings_manager.settings
                
                # í•„ìš”í•œ 4ê°œë§Œ ì¶”ì¶œ
                result_settings = {
                    'doorOpenTemp': int(settings.get('doorOpenTemp', 28)),
                    'doorCloseTemp': int(settings.get('doorCloseTemp', 24)),
                    'fanHumidityThreshold': int(settings.get('fanHumidityThreshold', 70)),
                    'fanCO2Threshold': int(settings.get('fanCO2Threshold', 1000))
                }
                
                logger.info(f"âœ… ê°„ë‹¨ ì„¤ì • ì¡°íšŒ: {result_settings}")
            except Exception as e:
                logger.warning(f"âš ï¸ ì„¤ì • ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: {e}")
        
        return jsonify({
            'success': True,
            'data': result_settings
        })

    except Exception as e:
        logger.error(f"âŒ ì„¤ì • ì¡°íšŒ ì‹¤íŒ¨: {e}")
        return jsonify({
            'success': True,
            'data': {
                'doorOpenTemp': 28,
                'doorCloseTemp': 24,
                'fanHumidityThreshold': 70,
                'fanCO2Threshold': 1000
            }
        })

@app.route('/api/sensor-history/<sensor_type>')
def get_sensor_history(sensor_type):
    """íŠ¹ì • ì„¼ì„œì˜ ìµœê·¼ 30ì´ˆê°„ íˆìŠ¤í† ë¦¬ ë°ì´í„° ì¡°íšŒ"""
    try:
        global sensor_history
        
        logger.info(f"ì„¼ì„œ íˆìŠ¤í† ë¦¬ ìš”ì²­: {sensor_type}")
        
        # ìœ íš¨í•œ ì„¼ì„œ íƒ€ì…ì¸ì§€ í™•ì¸
        valid_sensors = ['temperature', 'humidity', 'lux', 'co2', 'no2', 'co', 'nh3']
        if sensor_type not in valid_sensors:
            logger.warning(f"ìœ íš¨í•˜ì§€ ì•Šì€ ì„¼ì„œ íƒ€ì…: {sensor_type}")
            return jsonify({
                'success': False,
                'message': f'ìœ íš¨í•˜ì§€ ì•Šì€ ì„¼ì„œ íƒ€ì…: {sensor_type}'
            }), 400
        
        # ì„¼ì„œ ë°ì´í„°ì™€ íƒ€ì„ìŠ¤íƒ¬í”„ ë°˜í™˜
        sensor_data = sensor_history.get(sensor_type, [])
        timestamps = sensor_history.get('timestamps', [])
        
        logger.info(f"ì„¼ì„œ ë°ì´í„° í¬ê¸°: {len(sensor_data)}, íƒ€ì„ìŠ¤íƒ¬í”„ í¬ê¸°: {len(timestamps)}")
        
        # ë°ì´í„° í¬ì¸íŠ¸ ìˆ˜ê°€ ì¼ì¹˜í•˜ë„ë¡ ì¡°ì •
        min_length = min(len(sensor_data), len(timestamps))
        sensor_data = sensor_data[-min_length:] if min_length > 0 else []
        timestamps = timestamps[-min_length:] if min_length > 0 else []
        
        logger.info(f"ì¡°ì •ëœ ë°ì´í„° í¬ê¸°: {len(sensor_data)}")
        
        return jsonify({
            'success': True,
            'data': {
                'sensor_type': sensor_type,
                'values': sensor_data,
                'timestamps': timestamps,
                'count': len(sensor_data)
            }
        })
        
    except Exception as e:
        logger.error(f"ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        return jsonify({
            'success': False,
            'message': f'ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}'
        }), 500

# Flask ì„œë²„ë¥¼ ë³„ë„ ì“°ë ˆë“œì—ì„œ ì‹¤í–‰
def run_flask():
    if HARDWARE_AVAILABLE:
        app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False)
    else:
        logging.warning("í•˜ë“œì›¨ì–´ê°€ ì‚¬ìš© ë¶ˆê°€ëŠ¥í•˜ì—¬ Flask ì„œë²„ë¥¼ ì‹œì‘í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")


class EnvConfig:
    """í™˜ê²½ ì„¼ì„œ ì„¤ì • (ìµœì í™”ëœ ë²„ì „)"""
    def __init__(self):
        # GPIO í•€ ì„¤ì •
        self.MOTOR_A = 24
        self.MOTOR_B = 23
        self.LED_PIN = 16
        self.SERVO_PIN = 18
        
        # ì„¼ì„œ ì±„ë„
        self.LDR_CHANNEL = 0
        self.MQ_CHANNEL = 1
        
        # ì„¼ì„œ ë³´ì •ê°’
        self.RLOAD = 10.0
        self.RO_CLEAN_AIR_FACTOR = 9.83
        
        # ê°€ìŠ¤ ì„¼ì„œ ê³¡ì„  ê³„ìˆ˜
        self.CO2_CURVE_A = 116.6020682
        self.CO2_CURVE_B = -2.769034857
        self.CO_PARA = 23.943
        self.CO_PARB = 1.11
        self.NH3_PARA = 102.2
        self.NH3_PARB = 2.473
        self.NO2_PARA = 116.6020682
        self.NO2_PARB = 2.76963857
        
        # ì„œë³´ëª¨í„° ì„¤ì •
        self.SERVO_MIN_DUTY = 3
        self.SERVO_MAX_DUTY = 12
        
        # ê¸°íƒ€ ì„¤ì •
        self.FARM_NUM = 1
        self.FREQ = 100
        self.WARMUP_DURATION = 1800  # 30ë¶„
        
        # ì„œë³´ ëª¨í„° ê´€ë ¨ ì„¤ì •
        self.SERVO_THRESHOLD = 60  # ìŠµë„ ê¸°ì¤€ê°’


class EnvSettingsManager:
    """í™˜ê²½ ì„¤ì • ê´€ë¦¬"""
    
    def __init__(self, db_manager, farm_num=1):
        self.db_manager = db_manager
        self.farm_num = farm_num
        self.sunrise_sunset_api = SunriseSunsetAPI()
        self.settings = self.load_default_settings()
        self.last_update = None
    
    def load_default_settings(self):
        """ê¸°ë³¸ ì„¤ì •ê°’ ë¡œë“œ"""
        return {
            'ledThreshold': 300,
            'doorOpenTemp': 25,
            'doorCloseTemp': 15,
            'fanHumidityThreshold': 75,
            'fanCO2Threshold': 1000,
            'fanCOThreshold': 30,
            'fanSpeed': 60,
            'tempHighAlert': 35,
            'tempLowAlert': 10,
            'humidityHighAlert': 85,
            'humidityLowAlert': 30,
            'co2Alert': 2000, # ì„ê³„ê°’
            'coAlert': 50,
            'nh3Alert': 25,
            'envStatusGood': 80,
            'envStatusFair': 60,
            'autoLedMode': True,
            'manualLedThreshold': 300,
            'locationLat': 37.5665,
            'locationLng': 126.9780,
            'sleepStartHour': 22,
            'sleepEndHour': 6,
            'sleepModeEnabled': True,
            'servoThreshold': 60,
            'useSimpleSensorMode': False  # ê³ ê¸‰ ëª¨ë“œ ì‚¬ìš© (ì„¼ì„œ íŠ¹ì„±ê³¡ì„  ì ìš©)
        }
    
    def load_settings_from_backend(self):
        """ìŠ¤í”„ë§ ë°±ì—”ë“œì—ì„œ ì„¤ì •ì„ ê°€ì ¸ì˜´"""
        try:
            response = requests.get('http://192.168.30.111:8080/api/env-settings', timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                if data.get('success'):
                    settings_data = data.get('data', {})
                    self.settings.update(settings_data)
                    logger.debug(f"ë°±ì—”ë“œ ì„¤ì • ë¡œë“œ ì„±ê³µ")
                    return True
                else:
                    logger.warning(f"ë°±ì—”ë“œ ì‘ë‹µ ì‹¤íŒ¨: {data}")
            else:
                logger.warning(f"ë°±ì—”ë“œ ì—°ê²° ì‹¤íŒ¨: {response.status_code}")
        except Exception as e:
            logger.error(f"ë°±ì—”ë“œ ì„¤ì • ë¡œë“œ ì‹¤íŒ¨: {e}")
        
        return False

    def load_settings_from_db(self):
        """ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì„¤ì • ë¡œë“œ"""
        logger.debug("ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í™˜ê²½ ì„¤ì • ë¡œë“œ ì‹œë„...")
        
        # ë¨¼ì € ë°±ì—”ë“œì—ì„œ ì„¤ì • ë¡œë“œ ì‹œë„
        backend_success = self.load_settings_from_backend()
        if backend_success:
            return True
        
        # ë°±ì—”ë“œ ì‹¤íŒ¨ ì‹œ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¡œë“œ
        with self.db_manager.get_connection() as conn:
            if not conn:
                logger.error("ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì‹¤íŒ¨")
                return False
            
            try:
                cursor = conn.cursor()
                sql = "SELECT * FROM ENV_SETTINGS WHERE ID = 1"
                logger.info(f"SQL ì‹¤í–‰: {sql}")
                cursor.execute(sql)
                result = cursor.fetchone()
                
                if result:
                    logger.info(f"ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì„¤ì • ì¡°íšŒ ì„±ê³µ: {result}")
                    
                    # ë°ì´í„°ë² ì´ìŠ¤ ì»¬ëŸ¼ëª…ì„ ì„¤ì • í‚¤ë¡œ ë§¤í•‘
                    column_mapping = {
                        'LED_THRESHOLD': 'ledThreshold',
                        'DOOR_OPEN_TEMP': 'doorOpenTemp',
                        'DOOR_CLOSE_TEMP': 'doorCloseTemp',
                        'FAN_HUMIDITY_THRESHOLD': 'fanHumidityThreshold',
                        'FAN_CO2_THRESHOLD': 'fanCO2Threshold',
                        'FAN_CO_THRESHOLD': 'fanCOThreshold',
                        'FAN_SPEED': 'fanSpeed',
                        'TEMP_HIGH_ALERT': 'tempHighAlert',
                        'TEMP_LOW_ALERT': 'tempLowAlert',
                        'HUMIDITY_HIGH_ALERT': 'humidityHighAlert',
                        'HUMIDITY_LOW_ALERT': 'humidityLowAlert',
                        'CO2_ALERT': 'co2Alert',
                        'CO_ALERT': 'coAlert',
                        'NH3_ALERT': 'nh3Alert',
                        'ENV_STATUS_GOOD': 'envStatusGood',
                        'ENV_STATUS_FAIR': 'envStatusFair',
                        'AUTO_LED_MODE': 'autoLedMode',
                        'MANUAL_LED_THRESHOLD': 'manualLedThreshold',
                        'LOCATION_LAT': 'locationLat',
                        'LOCATION_LNG': 'locationLng',
                        'SLEEP_START_HOUR': 'sleepStartHour',
                        'SLEEP_END_HOUR': 'sleepEndHour',
                        'SLEEP_MODE_ENABLED': 'sleepModeEnabled',
                        'SERVO_THRESHOLD': 'servoThreshold',
                        'USE_SIMPLE_SENSOR_MODE': 'useSimpleSensorMode'
                    }
                    
                    # ê²°ê³¼ë¥¼ ë”•ì…”ë„ˆë¦¬ë¡œ ë³€í™˜
                    columns = [desc[0] for desc in cursor.description]
                    row_dict = dict(zip(columns, result))
                    logger.info(f"ì»¬ëŸ¼ ë§¤í•‘: {columns}")
                    logger.info(f"í–‰ ë°ì´í„°: {row_dict}")
                    
                    # ì„¤ì • ì—…ë°ì´íŠ¸
                    for db_col, setting_key in column_mapping.items():
                        if db_col in row_dict and row_dict[db_col] is not None:
                            old_value = self.settings.get(setting_key)
                            
                            # íƒ€ì…ë³„ ì²˜ë¦¬
                            if db_col in ['AUTO_LED_MODE', 'SLEEP_MODE_ENABLED', 'USE_SIMPLE_SENSOR_MODE']:
                                self.settings[setting_key] = bool(row_dict[db_col])
                            elif db_col in ['LOCATION_LAT', 'LOCATION_LNG']:
                                self.settings[setting_key] = float(row_dict[db_col])
                            elif db_col in ['SLEEP_START_HOUR', 'SLEEP_END_HOUR']:
                                self.settings[setting_key] = int(row_dict[db_col])
                            else:
                                self.settings[setting_key] = float(row_dict[db_col])
                            
                            logger.debug(f"ì„¤ì • ì—…ë°ì´íŠ¸: {setting_key}")
                    
                    self.last_update = datetime.now()
                    logger.debug(f"í™˜ê²½ ì„¤ì •ì´ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¡œë“œë¨")
                    return True
                else:
                    logger.warning("ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í™˜ê²½ ì„¤ì •ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ê°’ì„ ì‚¬ìš©í•©ë‹ˆë‹¤.")
                    return False
                    
            except mysql.connector.Error as err:
                logger.error(f'í™˜ê²½ ì„¤ì • ë¡œë“œ ì˜¤ë¥˜: {err}')
                return False
            finally:
                cursor.close()
    
    def get_setting(self, key, default=None):
        """ì„¤ì •ê°’ ì¡°íšŒ"""
        return self.settings.get(key, default)
    
    def update_setting(self, key, value):
        """ì„¤ì •ê°’ ì—…ë°ì´íŠ¸"""
        self.settings[key] = value
    
    def should_reload_settings(self):
        """ì„¤ì •ì„ ë‹¤ì‹œ ë¡œë“œí•´ì•¼ í•˜ëŠ”ì§€ í™•ì¸ (5ë¶„ë§ˆë‹¤)"""
        if self.last_update is None:
            return True
        
        time_diff = datetime.now() - self.last_update
        return time_diff.total_seconds() > 300  # 5ë¶„
    
    def get_led_threshold(self):
        """LED ê¸°ì¤€ê°’ ë°˜í™˜ (ìë™ ëª¨ë“œë©´ ì¼ëª°/ì¼ì¶œ ê¸°ë°˜ ê³„ì‚°, ìˆ˜ë™ ëª¨ë“œë©´ ìˆ˜ë™ ì„¤ì •ê°’)"""
        auto_mode = self.get_setting('autoLedMode', True)
        
        if auto_mode:
            # ìë™ ëª¨ë“œ: ì¼ëª°/ì¼ì¶œ ì‹œê°„ ê¸°ë°˜ ê³„ì‚°
            lat = self.get_setting('locationLat', 37.5665)
            lng = self.get_setting('locationLng', 126.9780)
            
            auto_threshold = self.sunrise_sunset_api.calculate_auto_led_threshold(lat, lng)
            logger.info(f"ìë™ LED ê¸°ì¤€ê°’ ê³„ì‚°: {auto_threshold} lux (ìœ„ë„: {lat}, ê²½ë„: {lng})")
            return auto_threshold
        else:
            # ìˆ˜ë™ ëª¨ë“œ: ì‚¬ìš©ì ì„¤ì •ê°’ ì‚¬ìš©
            manual_threshold = self.get_setting('manualLedThreshold', 300)
            logger.info(f"ìˆ˜ë™ LED ê¸°ì¤€ê°’ ì‚¬ìš©: {manual_threshold} lux")
            return manual_threshold
    
    def is_sleep_time(self):
        """í˜„ì¬ ì‹œê°„ì´ ìˆ˜ë©´ ì‹œê°„ì¸ì§€ í™•ì¸"""
        sleep_mode_enabled = self.get_setting('sleepModeEnabled', True)
        
        if not sleep_mode_enabled:
            return False
        
        sleep_start = self.get_setting('sleepStartHour', 22)
        sleep_end = self.get_setting('sleepEndHour', 6)
        current_hour = datetime.now().hour
        
        # ìˆ˜ë©´ ì‹œê°„ì´ ìì •ì„ ë„˜ì–´ê°€ëŠ” ê²½ìš° (ì˜ˆ: 22ì‹œ ~ 6ì‹œ)
        if sleep_start > sleep_end:
            return current_hour >= sleep_start or current_hour < sleep_end
        else:
            # ìˆ˜ë©´ ì‹œê°„ì´ ê°™ì€ ë‚  ë‚´ì— ìˆëŠ” ê²½ìš° (ì˜ˆ: 10ì‹œ ~ 18ì‹œ)
            return sleep_start <= current_hour < sleep_end


class SunriseSunsetAPI:
    """ì¼ëª°/ì¼ì¶œ ì‹œê°„ API í´ë˜ìŠ¤ (ê¸°ìƒì²­ API ìš°ì„  ì‚¬ìš©)"""
    
    def __init__(self):
        # ê¸°ìƒì²­ ë‹¨ê¸°ì˜ˆë³´ ì¡°íšŒì„œë¹„ìŠ¤ API
        self.kma_api_url = "http://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getUltraSrtFcst"
        self.kma_api_key = "YOUR_API_KEY"  # ì‹¤ì œ ì‚¬ìš©ì‹œ ê¸°ìƒì²­ API í‚¤ í•„ìš”
        
        # ë°±ì—…ìš© Sunrise-Sunset API
        self.sunrise_sunset_url = "https://api.sunrise-sunset.org/json"
        
        self.cache = {}  # ìºì‹œë¥¼ ìœ„í•œ ë”•ì…”ë„ˆë¦¬
        self.cache_duration = 3600  # 1ì‹œê°„ ìºì‹œ
    
    def get_sunrise_sunset_from_kma(self, lat: float, lng: float, date: str = None) -> Dict[str, Any]:
        """ê¸°ìƒì²­ APIë¡œ ì¼ëª°/ì¼ì¶œ ì‹œê°„ ì¡°íšŒ"""
        try:
            # ê¸°ìƒì²­ APIëŠ” ì¢Œí‘œë¥¼ ê²©ì ì¢Œí‘œë¡œ ë³€í™˜í•´ì•¼ í•¨
            nx, ny = self._lat_lng_to_grid(lat, lng)
            
            # í˜„ì¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì¡°íšŒ
            now = datetime.now()
            base_date = now.strftime('%Y%m%d')
            base_time = now.strftime('%H%M')
            
            params = {
                'serviceKey': self.kma_api_key,
                'numOfRows': 1000,
                'pageNo': 1,
                'dataType': 'JSON',
                'base_date': base_date,
                'base_time': base_time,
                'nx': nx,
                'ny': ny
            }
            
            response = requests.get(self.kma_api_url, params=params, timeout=10)
            response.raise_for_status()
            
            data = response.json()
            
            if data['response']['header']['resultCode'] == '00':
                items = data['response']['body']['items']['item']
                
                # ì¼ëª°/ì¼ì¶œ ì‹œê°„ ì°¾ê¸°
                sunrise_time = None
                sunset_time = None
                
                for item in items:
                    if item['category'] == 'SUNRISE':
                        sunrise_time = item['fcstTime']
                    elif item['category'] == 'SUNSET':
                        sunset_time = item['fcstTime']
                
                if sunrise_time and sunset_time:
                    result = {
                        'sunrise': sunrise_time,
                        'sunset': sunset_time,
                        'date': date or now.strftime('%Y-%m-%d'),
                        'source': 'KMA'
                    }
                    logger.info(f"ê¸°ìƒì²­ APIë¡œ ì¼ëª°/ì¼ì¶œ ì •ë³´ ì¡°íšŒ ì„±ê³µ: {date}")
                    return result
                else:
                    logger.warning("ê¸°ìƒì²­ APIì—ì„œ ì¼ëª°/ì¼ì¶œ ì‹œê°„ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ")
                    return None
            else:
                logger.error(f"ê¸°ìƒì²­ API ì˜¤ë¥˜: {data['response']['header']['resultMsg']}")
                return None
                
        except Exception as e:
            logger.error(f"ê¸°ìƒì²­ API ìš”ì²­ ì‹¤íŒ¨: {e}")
            return None
    
    def _lat_lng_to_grid(self, lat: float, lng: float) -> Tuple[int, int]:
        """ìœ„ë„/ê²½ë„ë¥¼ ê¸°ìƒì²­ ê²©ì ì¢Œí‘œë¡œ ë³€í™˜"""
        # ê¸°ìƒì²­ ê²©ì ì¢Œí‘œ ë³€í™˜ ê³µì‹
        RE = 6371.00877  # ì§€êµ¬ ë°˜ê²½(km)
        GRID = 5.0       # ê²©ì ê°„ê²©(km)
        SLAT1 = 30.0     # íˆ¬ì˜ ìœ„ë„1(degree)
        SLAT2 = 60.0     # íˆ¬ì˜ ìœ„ë„2(degree)
        OLON = 126.0     # ê¸°ì¤€ì  ê²½ë„(degree)
        OLAT = 38.0      # ê¸°ì¤€ì  ìœ„ë„(degree)
        XO = 43          # ê¸°ì¤€ì  Xì¢Œí‘œ(GRID)
        YO = 136         # ê¸°ì¤€ì  Yì¢Œí‘œ(GRID)1
        
        DEGRAD = math.pi / 180.0
        RADDEG = 180.0 / math.pi
        
        re = RE / GRID
        slat1 = SLAT1 * DEGRAD
        slat2 = SLAT2 * DEGRAD
        olon = OLON * DEGRAD
        olat = OLAT * DEGRAD
        
        sn = math.tan(math.pi * 0.25 + slat2 * 0.5) / math.tan(math.pi * 0.25 + slat1 * 0.5)
        sn = math.log(math.cos(slat1) / math.cos(slat2)) / math.log(sn)
        sf = math.tan(math.pi * 0.25 + slat1 * 0.5)
        sf = math.pow(sf, sn) * math.cos(slat1) / sn
        ro = math.tan(math.pi * 0.25 + olat * 0.5)
        ro = re * sf / math.pow(ro, sn)
        
        ra = math.tan(math.pi * 0.25 + lat * DEGRAD * 0.5)
        theta = lng * DEGRAD - olon
        
        x = math.floor(ra * math.sin(theta) + XO + 0.5)
        y = math.floor(ro - ra * math.cos(theta) + YO + 0.5)
        
        return int(x), int(y)
    
    def get_sunrise_sunset(self, lat: float, lng: float, date: str = None) -> Dict[str, Any]:
        """ì¼ëª°/ì¼ì¶œ ì‹œê°„ ì¡°íšŒ (ê¸°ìƒì²­ API ìš°ì„ , ë°±ì—…ìš© Sunrise-Sunset API)"""
        if date is None:
            date = datetime.now().strftime('%Y-%m-%d')
        
        cache_key = f"{lat}_{lng}_{date}"
        
        # ìºì‹œ í™•ì¸
        if cache_key in self.cache:
            cached_data, cached_time = self.cache[cache_key]
            if time.time() - cached_time < self.cache_duration:
                logger.info(f"ìºì‹œì—ì„œ ì¼ëª°/ì¼ì¶œ ì •ë³´ ë°˜í™˜: {date}")
                return cached_data
        
        # 1. ê¸°ìƒì²­ API ì‹œë„
        result = self.get_sunrise_sunset_from_kma(lat, lng, date)
        
        # 2. ê¸°ìƒì²­ API ì‹¤íŒ¨ì‹œ ë°±ì—… API ì‚¬ìš©
        if not result:
            logger.info("ê¸°ìƒì²­ API ì‹¤íŒ¨, ë°±ì—… API ì‚¬ìš©")
            try:
                params = {
                    'lat': lat,
                    'lng': lng,
                    'date': date,
                    'formatted': 0  # ISO 8601 í˜•ì‹ìœ¼ë¡œ ë°˜í™˜
                }
                
                response = requests.get(self.sunrise_sunset_url, params=params, timeout=10)
                response.raise_for_status()
                
                data = response.json()
                
                if data['status'] == 'OK':
                    result = {
                        'sunrise': data['results']['sunrise'],
                        'sunset': data['results']['sunset'],
                        'day_length': data['results']['day_length'],
                        'date': date,
                        'source': 'Sunrise-Sunset'
                    }
                    logger.info(f"ë°±ì—… APIë¡œ ì¼ëª°/ì¼ì¶œ ì •ë³´ ì¡°íšŒ ì„±ê³µ: {date}")
                else:
                    logger.error(f"ë°±ì—… API ì˜¤ë¥˜: {data}")
                    return None
                    
            except requests.RequestException as e:
                logger.error(f"ë°±ì—… API ìš”ì²­ ì‹¤íŒ¨: {e}")
                return None
            except Exception as e:
                logger.error(f"ë°±ì—… API ì •ë³´ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
                return None
        
        if result:
            # ìºì‹œì— ì €ì¥
            self.cache[cache_key] = (result, time.time())
            return result
        
        return None
    
    def calculate_auto_led_threshold(self, lat: float, lng: float) -> int:
        """ì¼ëª°/ì¼ì¶œ ì‹œê°„ì„ ê¸°ë°˜ìœ¼ë¡œ ìë™ LED ê¸°ì¤€ê°’ ê³„ì‚°"""
        try:
            # ì˜¤ëŠ˜ ë‚ ì§œì˜ ì¼ëª°/ì¼ì¶œ ì •ë³´ ì¡°íšŒ
            sunset_info = self.get_sunrise_sunset(lat, lng)
            
            if not sunset_info:
                logger.warning("ì¼ëª°/ì¼ì¶œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ì–´ ê¸°ë³¸ê°’ ì‚¬ìš©")
                return 300
            
            # ì¼ëª° ì‹œê°„ íŒŒì‹± (UTC ì‹œê°„)
            sunset_utc = datetime.fromisoformat(sunset_info['sunset'].replace('Z', '+00:00'))
            
            # í˜„ì¬ ì‹œê°„ (UTC)
            now_utc = datetime.now(tz=sunset_utc.tzinfo)
            
            # ì¼ëª° 1ì‹œê°„ ì „ë¶€í„° LED ì¼œê¸° ì‹œì‘
            led_start_time = sunset_utc - timedelta(hours=1)
            
            # ì¼ì¶œ 1ì‹œê°„ í›„ê¹Œì§€ LED ì¼œê¸° ìœ ì§€
            sunrise_utc = datetime.fromisoformat(sunset_info['sunrise'].replace('Z', '+00:00'))
            led_end_time = sunrise_utc + timedelta(hours=1)
            
            # í˜„ì¬ ì‹œê°„ì´ LED ì¼œì•¼ í•  ì‹œê°„ëŒ€ì¸ì§€ í™•ì¸
            if led_start_time <= now_utc <= led_end_time:
                # ë°¤ ì‹œê°„ëŒ€: ë‚®ì€ ì¡°ë„ì—ì„œë„ LED ì¼œê¸° (ê¸°ì¤€ê°’ ë‚®ì¶¤)
                auto_threshold = 200
                logger.info(f"ë°¤ ì‹œê°„ëŒ€ LED ê¸°ì¤€ê°’: {auto_threshold} lux")
            else:
                # ë‚® ì‹œê°„ëŒ€: ë†’ì€ ì¡°ë„ì—ì„œë§Œ LED ì¼œê¸° (ê¸°ì¤€ê°’ ë†’ì„)
                auto_threshold = 500
                logger.info(f"ë‚® ì‹œê°„ëŒ€ LED ê¸°ì¤€ê°’: {auto_threshold} lux")
            
            return auto_threshold
            
        except Exception as e:
            logger.error(f"ìë™ LED ê¸°ì¤€ê°’ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 300  # ê¸°ë³¸ê°’ ë°˜í™˜


class DatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ê´€ë¦¬ (ìµœì í™”ëœ ë²„ì „)"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self._connection_pool = []
        self._max_pool_size = 5
    
    @contextmanager
    def get_connection(self):
        conn = None
        try:
            # ì—°ê²° í’€ì—ì„œ ê¸°ì¡´ ì—°ê²° ì¬ì‚¬ìš© ì‹œë„
            if self._connection_pool:
                conn = self._connection_pool.pop()
                if conn.is_connected():
                    yield conn
                    return
                else:
                    conn.close()
            
            # ìƒˆ ì—°ê²° ìƒì„±
            conn = mysql.connector.connect(**self.config)
            yield conn
        except mysql.connector.Error as err:
            logger.error(f'ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì˜¤ë¥˜: {err}')
            yield None
        finally:
            if conn and conn.is_connected():
                # ì—°ê²°ì„ í’€ì— ë°˜í™˜ (ìµœëŒ€ í¬ê¸° ì œí•œ)
                if len(self._connection_pool) < self._max_pool_size:
                    self._connection_pool.append(conn)
                else:
                    conn.close()
    
    def save_farm_status(self, sensor_data: Dict[str, Any], farm_num: int) -> bool:
        """ì¶•ì‚¬ í™˜ê²½ ì •ë³´ ì €ì¥ (ë°°ì¹˜ ì²˜ë¦¬)"""
        with self.get_connection() as conn:
            if not conn:
                return False
            
            try:
                cursor = conn.cursor()
                sql = """
                INSERT INTO FARM_STATUS(
                    NO2_DATA, TEMP_DATA, HUM_DATA, LUX_DATA, 
                    CO_DATA, CO2_DATA, NH3_DATA, FARM_ID
                ) VALUES(%s, %s, %s, %s, %s, %s, %s, %s)
                """
                cursor.execute(sql, (
                    sensor_data['no2'],
                    sensor_data['temperature'],
                    sensor_data['humidity'],
                    sensor_data['lux'],
                    sensor_data['co'],
                    sensor_data['co2'],
                    sensor_data['nh3'],
                    farm_num
                ))
                conn.commit()
                logger.info(f"í™˜ê²½ ì •ë³´ ì €ì¥ ì™„ë£Œ")
                return True
            except mysql.connector.Error as err:
                logger.error(f'í™˜ê²½ ì •ë³´ ì €ì¥ ì˜¤ë¥˜: {err}')
                return False
            finally:
                cursor.close()
    
    def save_danger_notice(self, content: str, category: str, farm_num: int) -> bool:
        """ìœ„í—˜ ì•Œë¦¼ ì €ì¥"""
        with self.get_connection() as conn:
            if not conn:
                return False
            
            try:
                cursor = conn.cursor()
                sql = """
                INSERT INTO DANGER_NOTICE(
                    NOTICE_CONTENT, NOTICE_CATEGORY, FARM_NUM
                ) VALUES(%s, %s, %s)
                """
                cursor.execute(sql, (content, category, farm_num))
                conn.commit()
                logger.warning(f"âš ï¸ ìœ„í—˜ ì•Œë¦¼: [{category}] {content}")
                return True
            except mysql.connector.Error as err:
                logger.error(f'ìœ„í—˜ ì•Œë¦¼ ì €ì¥ ì˜¤ë¥˜: {err}')
                return False
            finally:
                cursor.close()
    
    def cleanup(self):
        """ì—°ê²° í’€ ì •ë¦¬"""
        for conn in self._connection_pool:
            if conn.is_connected():
                conn.close()
        self._connection_pool.clear()


class EnvSensorReader:
    """í™˜ê²½ ì„¼ì„œ ì½ê¸° (ìµœì í™”ëœ ë²„ì „)"""
    
    def __init__(self, config: EnvConfig):
        self.config = config
        if HARDWARE_AVAILABLE:
            self.spi = spidev.SpiDev()
            self.spi.open(0, 0)
            self.spi.max_speed_hz = 1000000
            self.dht_sensor = adafruit_dht.DHT22(board.D17)
        else:
            self.spi = None
            self.dht_sensor = None
        self.ro_value = 15.0
        self._last_readings = {}  # ìºì‹œëœ ì„¼ì„œ ê°’ë“¤
        self._cache_timeout = 5  # 5ì´ˆ ìºì‹œ
    
    def read_adc(self, channel: int) -> int:
        if not HARDWARE_AVAILABLE or not self.spi:
            return 512  # ì¤‘ê°„ê°’ ë°˜í™˜
        
        if channel > 7 or channel < 0:
            return -1
        r = self.spi.xfer2([1, (8 + channel) << 4, 0])
        return ((r[1] & 3) << 8) + r[2]
    
    def read_voltage_average(self, channel: int, samples: int = 3) -> float:
        """ì „ì•• í‰ê· ê°’ ì½ê¸° (ìƒ˜í”Œ ìˆ˜ ìµœì í™”)"""
        if not HARDWARE_AVAILABLE:
            return 2.5  # ê¸°ë³¸ê°’
        
        total = sum(self.read_adc(channel) * 5.0 / 1024.0 for _ in range(samples))
        return total / samples
    
    def read_dht_sensor(self, max_retries: int = 2) -> Tuple[Optional[float], Optional[float]]:
        """DHT ì„¼ì„œ ì½ê¸° (ì¬ì‹œë„ íšŸìˆ˜ ìµœì í™”)"""
        if not HARDWARE_AVAILABLE or not self.dht_sensor:
            return 25.0, 60.0  # ê¸°ë³¸ê°’
        
        for attempt in range(max_retries):
            try:
                humidity = self.dht_sensor.humidity
                temperature = self.dht_sensor.temperature
                
                if humidity is not None and temperature is not None:
                    return temperature, humidity
            except RuntimeError as err:
                logger.warning(f'DHT ì„¼ì„œ ì½ê¸° ì˜¤ë¥˜ ({attempt+1}/{max_retries}): {err}')
                if attempt < max_retries - 1:
                    time.sleep(1)  # ëŒ€ê¸° ì‹œê°„ ë‹¨ì¶•
        
        return None, None
    
    def calculate_rs(self, voltage: float) -> float:
        if voltage >= 4.9 or voltage <= 0.1:
            return -1
        rs = ((5.0 * self.config.RLOAD) / voltage) - self.config.RLOAD
        return max(0.1, rs)
    
    def calculate_co2(self, voltage: float, humidity: Optional[float] = None) -> float:
        if self.ro_value <= 0:
            return 400
        
        rs = self.calculate_rs(voltage)
        if rs <= 0:
            return 400
        
        ratio = rs / self.ro_value
        
        if humidity is not None and humidity > 60:
            humidity_factor = 1.0 + (humidity - 60) * 0.005
            ratio *= humidity_factor
        
        co2_ppm = self.config.CO2_CURVE_A * math.pow(ratio, self.config.CO2_CURVE_B) * 100
        
        if co2_ppm < 350:
            co2_ppm = 350 + (4.0 - ratio) * 50
        elif co2_ppm > 5000:
            co2_ppm = 5000
        
        return co2_ppm
    
    def calculate_gas(self, adc_value: int, gas_type: str) -> float:
        if adc_value <= 0:
            return 0
        
        voltage = (adc_value / 1024.0) * 5.0
        rs = self.calculate_rs(voltage)
        if rs <= 0:
            return 0
        
        rzero = self.ro_value if self.ro_value > 0 else 64.13
        ratio = rs / rzero
        
        gas_params = {
            "NO2": (self.config.NO2_PARA, self.config.NO2_PARB),
            "CO": (self.config.CO_PARA, self.config.CO_PARB),
            "NH3": (self.config.NH3_PARA, self.config.NH3_PARB)
        }
        
        if gas_type in gas_params:
            para, parb = gas_params[gas_type]
            concentration = para * math.pow(ratio, -parb)
            return max(0, concentration)
        
        return 0
    
    def read_all_sensors(self) -> Dict[str, Any]:
        """ëª¨ë“  ì„¼ì„œ ì½ê¸° (ìºì‹œ í™œìš©)"""
        current_time = time.time()
        
        # ìºì‹œëœ ê°’ì´ ìœ íš¨í•œì§€ í™•ì¸
        if (self._last_readings and 
            current_time - self._last_readings.get('timestamp', 0) < self._cache_timeout):
            return self._last_readings
        
        # ì„¼ì„œ ê°’ ì½ê¸°
        temperature, humidity = self.read_dht_sensor()
        
        # ADC ê°’ë“¤ ì½ê¸°
        ldr_adc = self.read_adc(self.config.LDR_CHANNEL)
        mq_adc = self.read_adc(self.config.MQ_CHANNEL)
        
        # ì¡°ë„ ê³„ì‚°
        lux = (ldr_adc / 1024.0) * 1000 if ldr_adc > 0 else 0
        
        # ê°€ìŠ¤ ë†ë„ ê³„ì‚°
        co2 = self.calculate_co2(mq_adc, humidity)
        co = self.calculate_gas(mq_adc, "CO")
        nh3 = self.calculate_gas(mq_adc, "NH3")
        no2 = self.calculate_gas(mq_adc, "NO2")
        
        sensor_data = {
            'temperature': temperature or 25.0,
            'humidity': humidity or 60.0,
            'lux': lux,
            'co2': co2,
            'co': co,
            'nh3': nh3,
            'no2': no2,
            'timestamp': current_time
        }
        
        # ìºì‹œ ì—…ë°ì´íŠ¸
        self._last_readings = sensor_data
        
        return sensor_data
    
    def read_simple_gas_sensors(self):
        """ê°„ë‹¨í•œ ê°€ìŠ¤ ì„¼ì„œ ì½ê¸° (env_monitor_simple.py ë°©ì‹)"""
        if not HARDWARE_AVAILABLE:
            # ê° ê°€ìŠ¤ë³„ë¡œ ì ì • ë²”ìœ„ì˜ ê¸°ë³¸ê°’ ì„¤ì •
            return {
                'nh3': 15,    # 15ppm ì •ë„
                'co2': 400,   # 400ppm ì •ë„
                'no2': 20,    # 20ppb ì •ë„
                'co': 5       # 5ppm ì •ë„
            }
        
        try:
            # ADC ì›ì‹œ ê°’ ì½ê¸°
            nh3_raw = self.read_adc(1)  # NH3_CHANNEL
            co2_raw = self.read_adc(2)  # CO2_CHANNEL
            no2_raw = self.read_adc(3)  # NO2_CHANNEL
            co_raw = self.read_adc(4)   # CO_CHANNEL
            
            # ADC ê°’ì„ ì‹¤ì œ ë‹¨ìœ„ë¡œ ë³€í™˜
            sensors = {
                'nh3': round((nh3_raw / 1023.0) * 50, 1),    # 0-50 ppm
                'co2': round((co2_raw / 1023.0) * 2000, 1),  # 0-2000 ppm
                'no2': round((no2_raw / 1023.0) * 200, 1),   # 0-200 ppb
                'co': round((co_raw / 1023.0) * 100, 1)      # 0-100 ppm
            }
            return sensors
        except Exception as e:
            logger.error(f"ê°„ë‹¨í•œ ê°€ìŠ¤ ì„¼ì„œ ì½ê¸° ì‹¤íŒ¨: {e}")
            return {
                'nh3': 15,
                'co2': 400,
                'no2': 20,
                'co': 5
            }
    
    def cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        if self.spi:
            self.spi.close()


class DynamicDeviceController:
    """ë™ì  ì„¤ì •ì„ ì§€ì›í•˜ëŠ” ì¥ì¹˜ ì œì–´"""
    
    def __init__(self, config, settings_manager):
        self.config = config
        self.settings_manager = settings_manager
        self.servo_position = 90
        self.led_status = "OFF"
        self.fan_status = False
        self.door_status = "ë‹«í˜"
        self.window_status = "ë‹«í˜"
        self._setup_gpio()
        self._setup_pwm()
    
    def _setup_gpio(self):
        GPIO.setmode(GPIO.BCM)
        GPIO.setup(self.config.MOTOR_A, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(self.config.MOTOR_B, GPIO.OUT, initial=GPIO.LOW)
        GPIO.setup(self.config.LED_PIN, GPIO.OUT)
        GPIO.setup(self.config.SERVO_PIN, GPIO.OUT)
    
    def _setup_pwm(self):
        self.pwm_a = GPIO.PWM(self.config.MOTOR_A, self.config.FREQ)
        self.pwm_b = GPIO.PWM(self.config.MOTOR_B, self.config.FREQ)
        self.servo = GPIO.PWM(self.config.SERVO_PIN, 50)
        
        self.pwm_a.start(0)
        self.pwm_b.start(0)
        self.servo.start(0)
        
        self.set_servo_angle(90)
    
    def set_servo_angle(self, angle: int):
        angle = max(0, min(180, angle))
        duty = self.config.SERVO_MIN_DUTY + \
            (angle * (self.config.SERVO_MAX_DUTY - self.config.SERVO_MIN_DUTY) / 180.0)
        self.servo.ChangeDutyCycle(duty)
        time.sleep(0.5)
        self.servo.ChangeDutyCycle(0)
        self.servo_position = angle
    
    def control_led(self, lux):
        # ìˆ˜ë©´ ì‹œê°„ í™•ì¸
        if self.settings_manager.is_sleep_time():
            if self.led_status != "OFF (ìˆ˜ë©´ì‹œê°„)":
                old_status = self.led_status
                self.led_status = "OFF (ìˆ˜ë©´ì‹œê°„)"
                print(f"LED {old_status} -> {self.led_status}")
            GPIO.output(self.config.LED_PIN, GPIO.LOW)
            return self.led_status
        
        # ìë™/ìˆ˜ë™ ëª¨ë“œì— ë”°ë¼ LED ê¸°ì¤€ê°’ ê³„ì‚°
        threshold = self.settings_manager.get_led_threshold()
        
        if lux <= threshold:
            if self.led_status != "ON":
                old_status = self.led_status
                self.led_status = "ON"
                print(f"LED {old_status} -> {self.led_status}")
            GPIO.output(self.config.LED_PIN, GPIO.HIGH)
            return self.led_status
        else:
            if self.led_status != "OFF":
                old_status = self.led_status
                self.led_status = "OFF"
                print(f"LED {old_status} -> {self.led_status}")
            GPIO.output(self.config.LED_PIN, GPIO.LOW)
            return self.led_status
    
    def control_door(self, temp):
        open_temp = self.settings_manager.get_setting('doorOpenTemp', 25)
        close_temp = self.settings_manager.get_setting('doorCloseTemp', 15)
        
        # íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ ì¶”ê°€ (ê¸°ì¤€ê°’ Â±2Â°C)
        hysteresis = 2.0
        
        # ë¬¸ì´ ì—´ë ¤ìˆëŠ” ìƒíƒœì—ì„œ ë‹«í˜ ê¸°ì¤€ í™•ì¸
        if self.servo_position == 180:  # ë¬¸ì´ ì—´ë ¤ìˆì„ ë•Œ
            if temp <= (open_temp - hysteresis):  # ì—´ë¦¼ ê¸°ì¤€ë³´ë‹¤ 2ë„ ë‚®ì•„ì•¼ ë‹«ê¸°
                self.set_servo_angle(0)
                old_status = self.door_status
                self.door_status = "ë‹«í˜"
                print(f"ë¬¸ {old_status} -> {self.door_status}")
        else:  # ë¬¸ì´ ë‹«í˜€ìˆì„ ë•Œ
            if temp >= (close_temp + hysteresis):  # ë‹«í˜ ê¸°ì¤€ë³´ë‹¤ 2ë„ ë†’ì•„ì•¼ ì—´ê¸°
                self.set_servo_angle(180)
                old_status = self.door_status
                self.door_status = "ì—´ë¦¼"
                print(f"ë¬¸ {old_status} -> {self.door_status}")
    
    def control_servo(self, humidity):
        """ì„œë³´ ëª¨í„° ì œì–´ (ì°½ë¬¸) - ìŠµë„ ê¸°ë°˜"""
        if not HARDWARE_AVAILABLE:
            logger.info(f"ì„œë³´ ì œì–´ (ì‹œë®¬ë ˆì´ì…˜): ìŠµë„ {humidity}%")
            return
        
        try:
            threshold = self.settings_manager.get_setting('servoThreshold', 60)
            hysteresis = 5.0  # ìŠµë„ íˆìŠ¤í…Œë¦¬ì‹œìŠ¤ Â±5%
            
            # ì°½ë¬¸ì´ ì—´ë ¤ìˆëŠ” ìƒíƒœì—ì„œ ë‹«í˜ ê¸°ì¤€ í™•ì¸
            if self.servo_position == 90:  # ì°½ë¬¸ì´ ì—´ë ¤ìˆì„ ë•Œ
                if humidity <= (threshold - hysteresis):  # ê¸°ì¤€ë³´ë‹¤ 5% ë‚®ì•„ì•¼ ë‹«ê¸°
                    self.set_servo_angle(0)
                    old_status = self.window_status
                    self.window_status = "ë‹«í˜"
                    print(f"ì°½ë¬¸ {old_status} -> {self.window_status}")
            else:  # ì°½ë¬¸ì´ ë‹«í˜€ìˆì„ ë•Œ
                if humidity >= (threshold + hysteresis):  # ê¸°ì¤€ë³´ë‹¤ 5% ë†’ì•„ì•¼ ì—´ê¸°
                    self.set_servo_angle(90)
                    old_status = self.window_status
                    self.window_status = "ì—´ë¦¼"
                    print(f"ì°½ë¬¸ {old_status} -> {self.window_status}")
                
        except Exception as e:
            logger.error(f"ì„œë³´ ì œì–´ ì‹¤íŒ¨: {e}")
    
    def control_fan(self, sensor_data):
        """íŒ¬ ì œì–´"""
        global device_states
        if not HARDWARE_AVAILABLE:
            logger.info(f"íŒ¬ ì œì–´ (ì‹œë®¬ë ˆì´ì…˜): CO2 {sensor_data.get('co2', 0):.1f}ppm")
            return False, "ì‹œë®¬ë ˆì´ì…˜"
        
        fan_needed = False
        reasons = []
        
        humidity_threshold = self.settings_manager.get_setting('fanHumidityThreshold', 75)
        co2_threshold = self.settings_manager.get_setting('fanCO2Threshold', 2000) 
        nh3_threshold = self.settings_manager.get_setting('nh3Threshold', 15)
        co_threshold = self.settings_manager.get_setting('fanCOThreshold', 30)
        fan_speed = self.settings_manager.get_setting('fanSpeed', 60)
        

        if sensor_data.get('humidity', 0) >= humidity_threshold:
            fan_needed = True
            reasons.append(f"ê³ ìŠµë„")
        
        if sensor_data.get('co2', 0) > co2_threshold:
            fan_needed = True
            reasons.append(f"CO2ë†’ìŒ")

        if sensor_data.get('nh3', 0) > nh3_threshold:
            fan_needed = True
            reasons.append(f"NH3ë†’ìŒ")
        
        if sensor_data.get('co', 0) > co_threshold:
            fan_needed = True
            reasons.append(f"COë†’ìŒ")
        
        try:
            if fan_needed:
            # ìƒíƒœ ë³€ê²½ ì²´í¬ë¥¼ device_statesë¡œ
                if not device_states.get('airPen', False):
                    logger.info(f"íŒ¬ OFF -> ON")
                    GPIO.output(self.config.MOTOR_A, GPIO.HIGH)  # ì¶”ê°€í•œ ë¶€ë¶„
                    self.pwm_a.ChangeDutyCycle(fan_speed)
                    self.fan_status = True
                return True, ", ".join(reasons)
            else:
                # ìƒíƒœ ë³€ê²½ ì²´í¬ë¥¼ device_statesë¡œ
                if device_states.get('airPen', False):
                    logger.info(f" íŒ¬ ON -> OFF")
                self.pwm_a.ChangeDutyCycle(0)
                GPIO.output(self.config.MOTOR_A, GPIO.LOW) # ì¶”ê°€í•œ ë¶€ë¶„
                self.fan_status = False
            return False, ""
                
        except Exception as e:
            logger.error(f"íŒ¬ ì œì–´ ì‹¤íŒ¨: {e}")
            return False, f"ì œì–´ ì‹¤íŒ¨: {e}"
        
    def cleanup(self):
        self.pwm_a.ChangeDutyCycle(0)
        self.pwm_b.ChangeDutyCycle(0)
        self.servo.stop()
        self.pwm_a.stop()
        self.pwm_b.stop()
        GPIO.cleanup()


class WarmupManager:
    """ì„¼ì„œ ì˜ˆì—´ ê´€ë¦¬"""
    
    def __init__(self, duration: int):
        self.duration = duration  # ì˜ˆì—´ ì‹œê°„ (ì´ˆ)
        self.start_time = None
        self.is_warming = False
    
    def ask_warmup(self) -> bool:
        """ì˜ˆì—´ ì—¬ë¶€ ì„ íƒ"""
        # ì‚¬ìš©ì ì…ë ¥ ì „ì— API ì°¨ë‹¨ ìƒíƒœë¡œ ì„¤ì •
        global latest_sensor_data
        latest_sensor_data['is_warming'] = True
        
        print("\nğŸ”¥ ì„¼ì„œ ì˜ˆì—´ ì•ˆë‚´: ì •í™•í•œ ì¸¡ì •ì„ ìœ„í•´ 30ë¶„ê°„ ì˜ˆì—´ì„ ê¶Œì¥í•©ë‹ˆë‹¤.")
        
        while True:
            choice = input("\nì˜ˆì—´ì„ ì§„í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (y/n): ").strip().lower()
            if choice in ['y', 'yes', 'ã…›']:
                return True
            elif choice in ['n', 'no', 'ã…œ']:
                print("\nâš ï¸  ì˜ˆì—´ì„ ê±´ë„ˆëœë‹ˆë‹¤. ì´ˆê¸° ì¸¡ì •ê°’ì´ ë¶€ì •í™•í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n")
                # ì˜ˆì—´ì„ ê±´ë„ˆë›¸ ë•Œë„ ì •ìƒ ëª¨ë“œë¡œ ì „í™˜
                latest_sensor_data['is_warming'] = False
                return False
            else:
                print("ì˜ëª»ëœ ì…ë ¥ì…ë‹ˆë‹¤. 'y' ë˜ëŠ” 'n'ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
    
    def start_warmup(self):
        """ì˜ˆì—´ ì‹œì‘"""
        self.start_time = datetime.now()
        self.is_warming = True
        
        # ì „ì—­ ë³€ìˆ˜ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        global latest_sensor_data
        latest_sensor_data['is_warming'] = True
        logger.info(f"ì„¼ì„œ ì˜ˆì—´ ì‹œì‘ (ì˜ˆìƒ ì†Œìš”ì‹œê°„: {self.duration//60}ë¶„)")
    
    def get_progress(self) -> Tuple[int, int, bool]:
        """ì˜ˆì—´ ì§„í–‰ë¥  ë°˜í™˜ (ê²½ê³¼ ì‹œê°„, ë‚¨ì€ ì‹œê°„, ì™„ë£Œ ì—¬ë¶€)"""
        if not self.is_warming or self.start_time is None:
            return 0, 0, True
        
        elapsed = int((datetime.now() - self.start_time).total_seconds())
        remaining = max(0, self.duration - elapsed)
        is_complete = elapsed >= self.duration
        
        return elapsed, remaining, is_complete
    
    def print_progress(self, sensor_data: Optional[Dict[str, Any]] = None):
        """ì˜ˆì—´ ì§„í–‰ ìƒí™© ì¶œë ¥"""
        elapsed, remaining, is_complete = self.get_progress()
        
        if is_complete:
            self.is_warming = False
            print("\nâœ… ì˜ˆì—´ì™„ë£Œ")
            logger.info("ì„¼ì„œ ì˜ˆì—´ ì™„ë£Œ - ì •ìƒ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
            return
        
        progress_percent = (elapsed / self.duration) * 100
        elapsed_min = elapsed // 60
        remaining_min = remaining // 60
        
        # 10ì´ˆë§ˆë‹¤ë§Œ ì¶œë ¥
        if elapsed % 10 == 0:
            print(f"ğŸ”¥ì˜ˆì—´ {progress_percent:.0f}% ({elapsed_min}ë¶„/{remaining_min}ë¶„)")
    
    def complete_warmup(self):
        """ì˜ˆì—´ ì™„ë£Œ ì²˜ë¦¬"""
        self.is_warming = False
        
        # ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
        global latest_sensor_data
        latest_sensor_data['is_warming'] = False
        
        print("\nâœ… ëª¨ë‹ˆí„°ë§ ì‹œì‘\n")


class DynamicEnvMonitorSystem:
    """ë™ì  ì„¤ì •ì„ ì§€ì›í•˜ëŠ” í™˜ê²½ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.config = EnvConfig()
        
        db_config = {
            'host': '192.168.30.111',
            'port': 3306,
            'user': 'rasberry',
            'password': 'mariadb',
            'database': 'team_db'
        }
        
        self.db_manager = DatabaseManager(db_config)
        self.sensor_reader = EnvSensorReader(self.config)
        
        # ì„¤ì • ê´€ë¦¬ì ì´ˆê¸°í™”
        self.settings_manager = EnvSettingsManager(self.db_manager, self.config.FARM_NUM)
        
        # ë™ì  ì„¤ì • ë¡œë“œ
        self.settings_manager.load_settings_from_db()
        
        # ë™ì  ì„¤ì •ì„ ì‚¬ìš©í•˜ëŠ” ì»¨íŠ¸ë¡¤ëŸ¬ë¡œ êµì²´
        self.device_controller = DynamicDeviceController(self.config, self.settings_manager)
        self.warmup_manager = WarmupManager(self.config.WARMUP_DURATION)
        
        logger.info("ë™ì  í™˜ê²½ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
    
    def read_sensors(self, use_simple_mode: bool = False) -> Optional[Dict[str, Any]]:
        """ì„¼ì„œ ë°ì´í„° ì½ê¸° (ê³ ê¸‰ ëª¨ë“œ ë˜ëŠ” ê°„ë‹¨ ëª¨ë“œ ì„ íƒ ê°€ëŠ¥)"""
        logger.debug(f"ì„¼ì„œ ì½ê¸° ì‹œì‘ - ê°„ë‹¨ ëª¨ë“œ: {use_simple_mode}")
        
        temp, hum = self.sensor_reader.read_dht_sensor()
        logger.debug(f"DHT ì„¼ì„œ ì½ê¸° ê²°ê³¼: temp={temp}, hum={hum}")
        
        if temp is None or hum is None:
            logger.warning("ì˜¨ìŠµë„ ì„¼ì„œ ì˜¤ë¥˜")
            return None
        
        lux = self.sensor_reader.read_adc(self.config.LDR_CHANNEL)
        logger.debug(f"LDR ì„¼ì„œ ì½ê¸° ê²°ê³¼: lux={lux}")
        
        if use_simple_mode:
            # ê°„ë‹¨ ëª¨ë“œ: env_monitor_simple.py ë°©ì‹
            gas_data = self.sensor_reader.read_simple_gas_sensors()
            return {
                'temperature': temp,
                'humidity': hum,
                'lux': lux,
                'co2': gas_data['co2'],
                'no2': gas_data['no2'],
                'co': gas_data['co'],
                'nh3': gas_data['nh3']
            }
        else:
            # ê³ ê¸‰ ëª¨ë“œ: ê¸°ì¡´ ë°©ì‹ (ì„¼ì„œ íŠ¹ì„±ê³¡ì„  ì‚¬ìš©)
            mq_voltage = self.sensor_reader.read_voltage_average(self.config.MQ_CHANNEL)
            co2 = self.sensor_reader.calculate_co2(mq_voltage, hum)
            
            mq_adc = self.sensor_reader.read_adc(self.config.MQ_CHANNEL)
            no2 = self.sensor_reader.calculate_gas(mq_adc, "NO2")
            co = self.sensor_reader.calculate_gas(mq_adc, "CO")
            nh3 = self.sensor_reader.calculate_gas(mq_adc, "NH3")
            
            return {
                'temperature': temp,
                'humidity': hum,
                'lux': lux,
                'co2': co2,
                'no2': no2,
                'co': co,
                'nh3': nh3
            }
    
    def check_dangers(self, sensor_data: Dict[str, Any], is_warming: bool = False):
        """ë™ì  ì„¤ì •ì„ ì‚¬ìš©í•œ ìœ„í—˜ ì•Œë¦¼ ì²´í¬ (ì˜ˆì—´ ì¤‘ì¼ ë•ŒëŠ” ì €ì¥í•˜ì§€ ì•ŠìŒ)"""
        if is_warming:
            logger.info("ì˜ˆì—´ ì¤‘ì´ë¯€ë¡œ ìœ„í—˜ ì•Œë¦¼ì„ ì €ì¥í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
            return
            
        temp = sensor_data.get('temperature')
        if temp:
            temp_high_alert = self.settings_manager.get_setting('tempHighAlert', 35)
            temp_low_alert = self.settings_manager.get_setting('tempLowAlert', 10)
            
            if temp >= temp_high_alert:
                self.db_manager.save_danger_notice(
                    f'ğŸŒ¡ï¸ ì˜¨ë„ê°€ {temp:.1f}Â°Cë¡œ ë„ˆë¬´ ë†’ìŠµë‹ˆë‹¤.', 
                    'ì˜¨ë„', self.config.FARM_NUM)
            elif temp <= temp_low_alert:
                self.db_manager.save_danger_notice(
                    f'ğŸŒ¡ï¸ ì˜¨ë„ê°€ {temp:.1f}Â°Cë¡œ ë„ˆë¬´ ë‚®ìŠµë‹ˆë‹¤.', 
                    'ì˜¨ë„', self.config.FARM_NUM)
        
        hum = sensor_data.get('humidity')
        if hum:
            humidity_high_alert = self.settings_manager.get_setting('humidityHighAlert', 85)
            humidity_low_alert = self.settings_manager.get_setting('humidityLowAlert', 30)
            
            if hum >= humidity_high_alert:
                self.db_manager.save_danger_notice(
                    f'ğŸ’§ ìŠµë„ê°€ {hum:.1f}%ë¡œ ë„ˆë¬´ ë†’ìŠµë‹ˆë‹¤.', 
                    'ìŠµë„', self.config.FARM_NUM)
            elif hum <= humidity_low_alert:
                self.db_manager.save_danger_notice(
                    f'ğŸ’§ ìŠµë„ê°€ {hum:.1f}%ë¡œ ë„ˆë¬´ ë‚®ìŠµë‹ˆë‹¤.', 
                    'ìŠµë„', self.config.FARM_NUM)
        
        co2_alert = self.settings_manager.get_setting('co2Alert', 2000) # ì„ê³„ê°’ ì¬ì„¤ì •
        if sensor_data.get('co2', 0) > co2_alert:
            self.db_manager.save_danger_notice(
                f'âš ï¸ CO2 ë†ë„ê°€ {sensor_data["co2"]:.1f}ppmìœ¼ë¡œ ë„ˆë¬´ ë†’ìŠµë‹ˆë‹¤.', 
                'CO2', self.config.FARM_NUM)
        
        co_alert = self.settings_manager.get_setting('coAlert', 50)
        if sensor_data.get('co', 0) > co_alert:
            self.db_manager.save_danger_notice(
                f'âš ï¸ CO ë†ë„ê°€ {sensor_data["co"]:.3f}ppmìœ¼ë¡œ ìœ„í—˜í•©ë‹ˆë‹¤.', 
                'CO', self.config.FARM_NUM)
        
        nh3_alert = self.settings_manager.get_setting('nh3Alert', 25)
        if sensor_data.get('nh3', 0) > nh3_alert:
            self.db_manager.save_danger_notice(
                f'âš ï¸ ì•”ëª¨ë‹ˆì•„ ë†ë„ê°€ {sensor_data["nh3"]:.3f}ppmìœ¼ë¡œ ë†’ìŠµë‹ˆë‹¤.', 
                'NH3', self.config.FARM_NUM)
    
    def control_devices(self, sensor_data: Dict[str, Any]):
        """ë™ì  ì„¤ì •ì„ ì‚¬ìš©í•œ ì¥ì¹˜ ì œì–´ (ìë™ ëª¨ë“œì¼ ë•Œë§Œ)"""
        global control_modes  # ì „ì—­ ë³€ìˆ˜ ì„ ì–¸
        
        # LED ì œì–´ (ìë™ ëª¨ë“œì¼ ë•Œë§Œ)
        if control_modes.get('led', 'auto') == 'auto':
            self.device_controller.control_led(sensor_data['lux'])
        
        # ë¬¸ ì œì–´ (ìë™ ëª¨ë“œì¼ ë•Œë§Œ)
        temp = sensor_data.get('temperature')
        if temp is not None and control_modes.get('door', 'auto') == 'auto':
            self.device_controller.control_door(temp)
        
        # ìŠµë„ íŒ¬ ì œì–´ (ìë™ ëª¨ë“œì¼ ë•Œë§Œ)
        humidity = sensor_data.get('humidity')
        if humidity is not None and control_modes.get('humPen', 'auto') == 'auto':
            self.device_controller.control_servo(humidity)
        
        # ê³µê¸°ì§ˆ íŒ¬ ì œì–´ (ìë™ ëª¨ë“œì¼ ë•Œë§Œ)
        if control_modes.get('airPen', 'auto') == 'auto':
                result = self.device_controller.control_fan(sensor_data)
                if result is not None:
                    fan_active, _ = result
                    device_states['airPen'] = fan_active
        
    
    def print_status(self, sensor_data: Dict[str, Any]):
        timestamp = time.strftime("%H:%M")
        print(f"[{timestamp}] {sensor_data['temperature']:.1f}Â°C {sensor_data['humidity']:.0f}% "
              f"CO2:{sensor_data['co2']:.0f} CO:{sensor_data['co']:.1f} NH3:{sensor_data['nh3']:.1f}")
    
    def run(self):
        """ë©”ì¸ ì‹¤í–‰ ë£¨í”„ (ì„¤ì • ìë™ ë¦¬ë¡œë“œ í¬í•¨)"""
        global latest_sensor_data  # ì „ì—­ ë³€ìˆ˜ ì„ ì–¸ì„ í•¨ìˆ˜ ì‹œì‘ ë¶€ë¶„ì— í•œ ë²ˆë§Œ
        
        logger.info("="*60)
        logger.info("ë™ì  í™˜ê²½ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹œì‘")
        logger.info("="*60)
        
        # ì˜ˆì—´ ì—¬ë¶€ ì„ íƒ
        need_warmup = self.warmup_manager.ask_warmup()
        
        if need_warmup:
            self.warmup_manager.start_warmup()
        
        loop_count = 0
        
        try:
            while True:
                # ì„¤ì • ìë™ ë¦¬ë¡œë“œ (5ë¶„ë§ˆë‹¤)
                if self.settings_manager.should_reload_settings():
                    self.settings_manager.load_settings_from_db()
                
                # ì˜ˆì—´ ì¤‘ì¸ì§€ í™•ì¸
                if self.warmup_manager.is_warming:
                    # ì˜ˆì—´ ì¤‘ì¼ ë•ŒëŠ” ì „ì—­ ë³€ìˆ˜ì— ì˜ˆì—´ ìƒíƒœë§Œ ì—…ë°ì´íŠ¸
                    latest_sensor_data['is_warming'] = True
                    logger.debug(f"ì˜ˆì—´ ì¤‘ - is_warming ì„¤ì •: {latest_sensor_data['is_warming']}")
                    
                    # ì˜ˆì—´ ì¤‘ì—ë„ ê³µê¸°ì§ˆ ì„¼ì„œëŠ” ì½ì–´ì•¼ í•¨ (ì •í™•í•œ ì¸¡ì •ì„ ìœ„í•´)
                    temp, hum = self.sensor_reader.read_dht_sensor()
                    if temp is not None and hum is not None:
                        # ê³µê¸°ì§ˆ ì„¼ì„œ ì½ê¸° (ì˜ˆì—´ ì¤‘ì—ë„ í•„ìš”)
                        mq_voltage = self.sensor_reader.read_voltage_average(self.config.MQ_CHANNEL)
                        co2 = self.sensor_reader.calculate_co2(mq_voltage, hum)
                        
                        mq_adc = self.sensor_reader.read_adc(self.config.MQ_CHANNEL)
                        no2 = self.sensor_reader.calculate_gas(mq_adc, "NO2")
                        co = self.sensor_reader.calculate_gas(mq_adc, "CO")
                        nh3 = self.sensor_reader.calculate_gas(mq_adc, "NH3")
                        
                        simple_data = {
                            'temperature': temp,
                            'humidity': hum,
                            'co2': co2,
                            'no2': no2,
                            'co': co,
                            'nh3': nh3
                        }
                        self.warmup_manager.print_progress(simple_data)
                    else:
                        self.warmup_manager.print_progress()
                    
                    _, _, is_complete = self.warmup_manager.get_progress()
                    if is_complete:
                        self.warmup_manager.complete_warmup()
                    
                    time.sleep(1)
                    continue
                
                # ì„¼ì„œ ëª¨ë“œ ì„¤ì • í™•ì¸
                use_simple_mode = self.settings_manager.get_setting('useSimpleSensorMode', False)
                sensor_data = self.read_sensors(use_simple_mode)
                
                if sensor_data is None:
                    logger.warning("ì„¼ì„œ ë°ì´í„° ì½ê¸° ì‹¤íŒ¨ - ì¬ì‹œë„ ì¤‘...")
                    time.sleep(2)
                    continue
                
                logger.debug(f"ì„¼ì„œ ë°ì´í„° ì½ê¸° ì„±ê³µ: {sensor_data}")
                
                # ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
                latest_sensor_data = {
                    'temperature': round(sensor_data['temperature'], 1),
                    'humidity': round(sensor_data['humidity'], 1),
                    'lux': sensor_data['lux'],
                    'co2': round(sensor_data['co2'], 1),
                    'no2': round(sensor_data['no2'], 3),
                    'co': round(sensor_data['co'], 3),
                    'nh3': round(sensor_data['nh3'], 3),
                    'timestamp': datetime.now().isoformat(),
                    'is_warming': False
                }

                # ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ (2ì´ˆë§ˆë‹¤)
                if loop_count % 2 == 0:  # 2ì´ˆë§ˆë‹¤ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
                    update_sensor_history(latest_sensor_data)
                    logger.debug(f"ì„¼ì„œ íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸ë¨ - ì˜¨ë„: {latest_sensor_data['temperature']}, íˆìŠ¤í† ë¦¬ í¬ê¸°: {len(sensor_history['temperature'])}")
                
                # ì •ìƒ ëª¨ë‹ˆí„°ë§ ëª¨ë“œ
                self.check_dangers(sensor_data, is_warming=False)
                self.control_devices(sensor_data)
                
                if loop_count % 10 == 0:  # 10ì´ˆë§ˆë‹¤ ìƒíƒœ ì¶œë ¥
                    logger.debug(f"ìƒíƒœ ì¶œë ¥ ì‹œë„ - ì„¼ì„œ ë°ì´í„°: {sensor_data}")
                    self.print_status(sensor_data)
                
                # 5ë¶„ë§ˆë‹¤ DB ì €ì¥ (ì˜ˆì—´ ì¤‘ì´ ì•„ë‹ ë•Œë§Œ)
                if loop_count % 300 == 0 and loop_count > 0:
                    db_data = {
                        'temperature': round(sensor_data['temperature'], 1),
                        'humidity': round(sensor_data['humidity'], 1),
                        'lux': sensor_data['lux'],
                        'no2': round(sensor_data['no2'], 3),
                        'co': round(sensor_data['co'], 3),
                        'co2': round(sensor_data['co2'], 1),
                        'nh3': round(sensor_data['nh3'], 3)
                    }
                    self.db_manager.save_farm_status(db_data, self.config.FARM_NUM)
                    loop_count = 0
                
                time.sleep(1)
                loop_count += 1
        
        except KeyboardInterrupt:
            logger.info("\nì‹œìŠ¤í…œ ì¢…ë£Œ")
        
        finally:
            self.device_controller.cleanup()
            self.sensor_reader.spi.close()
            logger.info("ì •ë¦¬ ì™„ë£Œ")

# ==================== ìˆ˜ë™/ìë™ ì œì–´ ====================

device_states = {
    'door': False,
    'humPen': False,
    'airPen': False,
    'led': False
}

control_modes = {
    'door': 'auto',      # 'auto' ë˜ëŠ” 'manual'
    'humPen': 'auto',
    'airPen': 'auto',
    'led': 'auto'
}

@app.route('/api/control', methods=['POST'])
def control_device():
    global device_states, control_modes, system_instance
    
    data = request.json
    device = data.get('device')
    state = data.get('state')
    mode = data.get('mode')
    
    if not system_instance:
        logger.error(" system_instance ì—†ìŒ")
        return jsonify({'success': False, 'message': 'System not initialized'})
    
    controller = system_instance.device_controller
    sensor_data = latest_sensor_data
    
    # 1. ëª¨ë“œê°€ ì „ë‹¬ë˜ë©´ ëª¨ë“œ ì—…ë°ì´íŠ¸
    if mode:
        control_modes[device] = mode
        logger.info(f" ëª¨ë“œ ë³€ê²½ ì™„ë£Œ: control_modes = {control_modes}")
        
    # ìë™ ëª¨ë“œë¡œ ì „í™˜ ì‹œ ì¦‰ì‹œ ìë™ ì œì–´ ì‹¤í–‰
        if mode == 'auto':
            try:
                if device == 'led':
                    led_status = controller.control_led(sensor_data['lux'])
                    device_states['led'] = (led_status == "ON")
                    
                elif device == 'door':
                    controller.control_door(sensor_data['temperature'])
                    device_states['door'] = (controller.door_status == "ì—´ë¦¼")
                        
                elif device == 'humPen' or device == 'airPen':  # ğŸ”¥ ìˆ˜ì •!
                    # ğŸ”¥ ë‘˜ ë‹¤ ê°™ì€ íŒ¬ì´ë¯€ë¡œ í•¨ê»˜ ì œì–´
                    logger.info(f"ğŸ’¨ {device} ìë™ ì „í™˜ - íŒ¬ ì œì–´ ì‹¤í–‰")
                    result = controller.control_fan(sensor_data)
                    logger.info(f"ğŸ’¨ íŒ¬ ì œì–´ ê²°ê³¼: {result}")
                    
                    if result:
                        fan_active, fan_reason = result
                        device_states['humPen'] = fan_active
                        device_states['airPen'] = fan_active
                        logger.info(f"ğŸ’¨ íŒ¬ ìƒíƒœ ì—…ë°ì´íŠ¸: {fan_active} (ì´ìœ : {fan_reason})")
                
                return jsonify({
                    'success': True,
                    'message': f'{device} ìë™ ëª¨ë“œë¡œ ì „í™˜ë¨',
                    'mode': control_modes[device],
                    'state': device_states.get(device, False)
                })
                
            except Exception as e:
                logger.error(f" {device} ìë™ ì œì–´ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
                import traceback
                logger.error(traceback.format_exc())
                return jsonify({
                    'success': False,
                    'message': f'ìë™ ì œì–´ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}'
                }), 500
            
        elif mode == 'manual':
            pass

    
    # 2. stateê°€ ì „ë‹¬ë˜ë©´ ìˆ˜ë™ ì œì–´ ì‹¤í–‰
    if state is not None:
        logger.info(f" ìˆ˜ë™ ì œì–´: {device} -> {state}")
        control_modes[device] = 'manual'
        
        try:
            if device == 'door':
                controller.set_servo_angle(0 if state else 180)
                device_states['door'] = state
                
            elif device == 'humPen':
                if state:  # ON ë²„íŠ¼
                    fan_speed = controller.settings_manager.get_setting('fanSpeed', 60)
                    GPIO.output(controller.config.MOTOR_A, GPIO.HIGH)  
                    GPIO.output(controller.config.MOTOR_B, GPIO.LOW)   
                    controller.pwm_a.ChangeDutyCycle(fan_speed)
                else:  # OFF ë²„íŠ¼
                    controller.pwm_a.ChangeDutyCycle(0)
                    GPIO.output(controller.config.MOTOR_A, GPIO.LOW)  
                    GPIO.output(controller.config.MOTOR_B, GPIO.LOW)  
                device_states['humPen'] = state

            elif device == 'airPen':
                if state:  # ON ë²„íŠ¼
                    fan_speed = controller.settings_manager.get_setting('fanSpeed', 60)
                    GPIO.output(controller.config.MOTOR_A, GPIO.HIGH)  
                    GPIO.output(controller.config.MOTOR_B, GPIO.LOW)   
                    controller.pwm_b.ChangeDutyCycle(fan_speed)
                else:  # OFF ë²„íŠ¼
                    controller.pwm_b.ChangeDutyCycle(0)
                    GPIO.output(controller.config.MOTOR_A, GPIO.LOW)   
                    GPIO.output(controller.config.MOTOR_B, GPIO.LOW)   
                device_states['airPen'] = state
                
            elif device == 'led':
                GPIO.output(controller.config.LED_PIN, GPIO.HIGH if state else GPIO.LOW)
                device_states['led'] = state
            
            return jsonify({
                'success': True,
                'message': f'{device} ì œì–´ ì„±ê³µ',
                'mode': control_modes[device],  # control_modesì—ëŠ” 'manual' ì „ë‹¬
                'state': device_states[device]  # device_statesì—ëŠ” í•´ë‹¹ ê¸°ê¸° ì „ë‹¬
            })
            
        except Exception as e:
            import traceback
            logger.error(traceback.format_exc())
            return jsonify({
                'success': False,
                'message': str(e)
            }), 500
    
    # 3. stateë„ modeë„ ì—†ìœ¼ë©´ í˜„ì¬ ìƒíƒœë§Œ ë°˜í™˜
    return jsonify({
        'success': True,
        'mode': control_modes.get(device, 'auto'),
        'state': device_states.get(device, False)
    })


def run_flask():
    app.run(host='0.0.0.0', port=5000, debug=False, use_reloader=False, threaded=True)


def main():
    global system_instance, control_modes, device_states
    
    try:
        # Flask ì„œë²„ë¥¼ ë³„ë„ ì“°ë ˆë“œë¡œ ì‹œì‘
        flask_thread = threading.Thread(target=run_flask, daemon=True)
        flask_thread.start()
        logger.info("Flask ì„œë²„ ì‹œì‘ (í¬íŠ¸ 5000)")
        
        # ë™ì  í™˜ê²½ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì‹œì‘
        system_instance = DynamicEnvMonitorSystem()
        system_instance.run()
        
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}", exc_info=True)
        raise
    finally:
        GPIO.cleanup()


if __name__ == "__main__":
    main()
